drop trigger if exists "on_delete_bookmark_decrease_bookmark_count" on "public"."bookmarks";

drop trigger if exists "on_insert_bookmark_increase_bookmark_count" on "public"."bookmarks";

drop trigger if exists "on_insert_comment_create_notification" on "public"."comments";

drop function if exists "public"."create_image_post_comment_notification"();

drop function if exists "public"."create_image_post_comment_reply_notification"();

drop function if exists "public"."decrease_image_post_bookmark_count"();

drop function if exists "public"."increase_image_post_bookmark_count"();

create table "public"."note_posts" (
    "id" bigint generated by default as identity not null,
    "author" uuid not null default auth.uid(),
    "title" text not null default 'No Title'::text,
    "body" text not null default ''::text,
    "published" boolean not null default false,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "slug" text not null default 't'::text,
    "likes" integer not null default 0,
    "bookmarks" integer not null default 0,
    "comments" integer not null default 0,
    "tags" text[] not null default '{}'::text[],
    "prompts" text[] not null default '{}'::text[]
);


alter table "public"."note_posts" enable row level security;

alter table "public"."image_posts" add column "comments" integer not null default 0;

alter table "public"."notifications" add column "target_note_post" bigint;

CREATE UNIQUE INDEX note_posts_pkey ON public.note_posts USING btree (id);

alter table "public"."note_posts" add constraint "note_posts_pkey" PRIMARY KEY using index "note_posts_pkey";

alter table "public"."note_posts" add constraint "note_posts_author_fkey" FOREIGN KEY (author) REFERENCES profiles(uid) ON DELETE CASCADE not valid;

alter table "public"."note_posts" validate constraint "note_posts_author_fkey";

alter table "public"."notifications" add constraint "notifications_target_note_post_fkey" FOREIGN KEY (target_note_post) REFERENCES note_posts(id) not valid;

alter table "public"."notifications" validate constraint "notifications_target_note_post_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_comment_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
	commentable record;
	parent record;
	sended uuid[] = '{}'::uuid[];
	reply record;
	image_post bigint;
	note_post bigint;
	event_name text;
	reply_event_name text;
begin
	if new.commentable_type = 'image_post' then
		select * into commentable from "image_posts" where id=new.commentable_id;
		image_post = new.commentable_id;
		event_name = 'image_post_comment';
		reply_event_name = 'image_post_comment_reply';
	end if;
	if new.commentable_type = 'note_post' then
		select * into commentable from "note_posts" where id=new.commentable_id;
		note_post = new.commentable_id;
		event_name = 'note_post_comment';
		reply_event_name = 'note_post_comment_reply';
	end if;

  	if (new.author != commentable.author) then
  		insert into "notifications" (author, target_image_post, target_note_post, target_user, type)
      		values (new.author, image_post, note_post, commentable.author, event_name);
      		sended = array_append (sended, commentable.author);
    end if;

	if (new.parent_id is not null) then
   		select * into parent from comments where id=new.parent_id;
   		if (new.author != parent.author) then
  			insert into "notifications" (author, target_image_post, target_note_post, target_user, type)
      			values (new.author, image_post, note_post, parent.author, reply_event_name);
      			sended = array_append (sended, parent.author);
    	end if;

  		for reply in select * from comments where (parent_id=new.parent_id) loop
	  		if (new.author != reply.author) and (not (select reply.author = any (sended))) then
  				insert into "notifications" (author, target_image_post, target_note_post, target_user, type)
      				values (new.author, image_post, note_post, reply.author, reply_event_name);
      			sended = array_append (sended, reply.author);
  			end if;
		end loop;
	end if;
  	return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.decrease_bookmark_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
	case old.type
		when 'image_post' then
			update "image_posts" set bookmarks=(bookmarks - 1) where id=old.target;
		when 'note_post' then
			update "note_posts" set bookmarks=(bookmarks - 1) where id=old.target;
	end case;
  	RETURN old;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.decrease_comment_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
	case old.commentable_type
		when 'image_post' then
			update "image_posts" set comments=(comments - 1) where id=old.commentable_id;
		when 'note_post' then
			update "note_posts" set comments=(comments - 1) where id=old.commentable_id;
	end case;
  	RETURN old;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increase_bookmark_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
	case new.type
		when 'image_post' then
			update "image_posts" set bookmarks=(bookmarks + 1) where id=new.target;
		when 'note_post' then
			update "note_posts" set bookmarks=(bookmarks + 1) where id=new.target;
	end case;
  	RETURN new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increase_comment_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
	case new.commentable_type
		when 'image_post' then
			update "image_posts" set comments=(comments + 1) where id=new.commentable_id;
		when 'note_post' then
			update "note_posts" set comments=(comments + 1) where id=new.commentable_id;
	end case;
  	RETURN new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_like_notification()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
	notification_type text;
	image_post_id bigint;
	note_post_id bigint;
	comment_id bigint;
	user_id uuid;
begin
	case new.type
		when 'image_post' then
  			select author into user_id from "image_posts" where id=new.target;
			notification_type = 'image_post_like';
			image_post_id = new.target;
		when 'note_post' then
  			select author into user_id from "note_posts" where id=new.target;
			notification_type = 'note_post_like';
			note_post_id = new.target;
		when 'comment' then
  			select author, commentable_id into user_id, image_post_id from "comments" where id=new.target;
			notification_type = 'comment_like';
			comment_id = new.target;
	end case;

	if new.author = user_id then
		return new;
	end if;

	if exists (select from "notifications" where
		author = new.author and
		type = notification_type and
		(image_post_id is null or target_image_post = image_post_id) and
		(note_post_id is null or target_note_post = note_post_id) and
		(comment_id is null or target_comment = comment_id)
	) then
		return new;
	end if;

  	insert into "notifications" (author, target_image_post, target_note_post, target_comment, target_user, type)
      	values (new.author, image_post_id, note_post_id, comment_id, user_id, notification_type);
  	return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.decrease_like_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
	case old.type
		when 'image_post' then
			update "image_posts" set likes=(likes - 1) where id=old.target;
		when 'note_post' then
			update "note_posts" set likes=(likes - 1) where id=old.target;
		when 'comment' then
			update "comments" set likes=(likes - 1) where id=old.target;
	end case;
 	return old;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.increase_like_count()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
	case new.type
		when 'image_post' then
			update "image_posts" set likes=(likes + 1) where id=new.target;
		when 'note_post' then
			update "note_posts" set likes=(likes + 1) where id=new.target;
		when 'comment' then
			update "comments" set likes=(likes + 1) where id=new.target;
	end case;
 	return new;
end;
$function$
;

create policy "Enable delete for users based on user_id"
on "public"."note_posts"
as permissive
for delete
to authenticated
using ((auth.uid() = author));


create policy "Enable insert for authenticated users only"
on "public"."note_posts"
as permissive
for insert
to authenticated
with check ((auth.uid() = author));


create policy "Enable read access for all users"
on "public"."note_posts"
as permissive
for select
to public
using (((auth.uid() = author) OR (published = true)));


create policy "Enable update for users based on user_id"
on "public"."note_posts"
as permissive
for update
to authenticated
using ((auth.uid() = author))
with check ((auth.uid() = author));


CREATE TRIGGER on_delete_decrease_comment_count BEFORE DELETE ON public.comments FOR EACH ROW EXECUTE FUNCTION decrease_comment_count();

CREATE TRIGGER on_insert_increase_comment_count BEFORE INSERT ON public.comments FOR EACH ROW EXECUTE FUNCTION increase_comment_count();

CREATE TRIGGER on_delete_bookmark_decrease_bookmark_count BEFORE DELETE ON public.bookmarks FOR EACH ROW EXECUTE FUNCTION decrease_bookmark_count();

CREATE TRIGGER on_insert_bookmark_increase_bookmark_count BEFORE INSERT ON public.bookmarks FOR EACH ROW EXECUTE FUNCTION increase_bookmark_count();

CREATE TRIGGER on_insert_comment_create_notification BEFORE INSERT ON public.comments FOR EACH ROW EXECUTE FUNCTION create_comment_notification();


